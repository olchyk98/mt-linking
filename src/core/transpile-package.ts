import { PassThrough, Readable } from 'stream'
import { type ResolvedPackage, getPackageAtPath } from './get-package-at-path'
import { type LinkingStrategy, getLinkingStrategyForPackage } from './get-linking-strategy-for-package'
import { executeShellWithStream } from '../utils'

const strategyTranspileFnMap: Record<LinkingStrategy, TranspileFn> = {
  TRANSPILED: (absolutePath) => executeShellWithStream('yarn', [ '--cwd', absolutePath, 'transpile' ]),
  TRANSPILED_LEGACY: (absolutePath) => executeShellWithStream('yarn', [ '--cwd', absolutePath, 'build' ]),
  AMEND_NATIVE () {
    const readStream = new PassThrough({ objectMode: true })
    readStream.push('>> ðŸŸ¢ No transpilation is required for this linking strategy ðŸŸ¢ <<')
    readStream.end()
    return readStream
  },
  MAKEFILE_BUILD: (absolutePath) => executeShellWithStream('make', [ `-C ${absolutePath}` ]),
}

/**
 * Accepts resolved package or absolute path
 * to a package (may end with "package.json") and
 * returns Readable stream that produces logs
 * generated by the external command performing
 * transpilation and pushing logs.
 *
 * The stream will end on transpilation success
 * and error on transpilation error.
 *
 * The function will return null if specified
 * absolutePath does not lead to a valid package.
 *
 * The function will eturn null if "strategy"
 * is not specified, and no linking strategy
 * could automatically be found for the specified
 * package.
 * */
export function transpilePackage(absolutePath: string, $linkingStrategy?: LinkingStrategy): Readable | null
export function transpilePackage(absolutePath: ResolvedPackage, $linkingStrategy?: LinkingStrategy): Readable | null
export function transpilePackage(absolutePath: ResolvedPackage, $linkingStrategy: LinkingStrategy): Readable
export function transpilePackage (absolutePath: ResolvedPackage | string, $linkingStrategy?: LinkingStrategy): Readable | null {
  const resolvedPackage = typeof absolutePath === 'object' ? absolutePath : getPackageAtPath(absolutePath)
  if (resolvedPackage == null) return null
  const linkingStrategy = $linkingStrategy ?? getLinkingStrategyForPackage(resolvedPackage)
  if (linkingStrategy == null) return null
  return strategyTranspileFnMap[linkingStrategy](resolvedPackage.absolutePath)
}

type TranspileFn = (absolutePath: string) => Readable
